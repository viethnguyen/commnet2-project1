<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Common_Classes_Projects_ECE544: common.cpp Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>common.cpp</h1><div class="fragment"><pre class="fragment">00001 <span class="preprocessor">#include "common.h"</span>
00002 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00003 <span class="preprocessor">#include &lt;iostream&gt;</span>
00004 <span class="preprocessor">#include &lt;string.h&gt;</span>
00005 <span class="preprocessor">#include &lt;time.h&gt;</span>
00006 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00007 <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00008 
00009 <span class="comment">//================================================================</span>
00010 <span class="comment">// Packet Header class</span>
00011 <span class="comment">//</span>
00012 PacketHdr::PacketHdr()
00013 { 
00014   <a class="code" href="classPacketHdr.html#p1">length_</a> = 0;  
00015   <a class="code" href="classPacketHdr.html#p0">info_</a> = <span class="keyword">new</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[MAX_HEADER_SIZE] ;
00016 }
00017 
<a name="l00018"></a><a class="code" href="classPacketHdr.html#a3">00018</a> <span class="keywordtype">int</span> <a class="code" href="classPacketHdr.html#a3">PacketHdr::getIntegerInfo</a>(<span class="keywordtype">int</span> position)
00019 {
00020   <span class="keywordtype">int</span> val;
00021   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p = <a class="code" href="classPacketHdr.html#p0">info_</a> +position;
00022   val = *(p++);
00023   val = val &lt;&lt; 8 | *(p++);
00024   val = val &lt;&lt; 8 | *(p++);
00025   val = val &lt;&lt; 8 | *(p);
00026   
00027   <span class="keywordflow">return</span> val;
00028 }
00029 
<a name="l00030"></a><a class="code" href="classPacketHdr.html#a2">00030</a> <span class="keywordtype">short</span> <a class="code" href="classPacketHdr.html#a2">PacketHdr::getShortIntegerInfo</a>(<span class="keywordtype">int</span> position)
00031 {
00032   <span class="keywordtype">short</span> val;
00033   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p = <a class="code" href="classPacketHdr.html#p0">info_</a> + position;
00034   val = *(p++);
00035   val = val &lt;&lt; 8 | *(p++);
00036 
00037   <span class="keywordflow">return</span> val;
00038 }
00039 
<a name="l00040"></a><a class="code" href="classPacketHdr.html#a6">00040</a> <span class="keywordtype">void</span> <a class="code" href="classPacketHdr.html#a6">PacketHdr::setIntegerInfo</a>(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> position)
00041 {
00042   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p = <a class="code" href="classPacketHdr.html#p0">info_</a> + position;
00043   *(p++) =  a &gt;&gt; 24;
00044   *(p++) = (a &gt;&gt; 16) &amp; 0xFF;
00045   *(p++) = (a &gt;&gt; 8) &amp; 0xFF;
00046   *(p++) =  a &amp; 0xFF;
00047   <a class="code" href="classPacketHdr.html#p1">length_</a> +=4;
00048 }
00049 
<a name="l00050"></a><a class="code" href="classPacketHdr.html#a7">00050</a> <span class="keywordtype">void</span> <a class="code" href="classPacketHdr.html#a7">PacketHdr::setShortIntegerInfo</a>(<span class="keywordtype">short</span> b, <span class="keywordtype">int</span> position)
00051 {
00052   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *p = <a class="code" href="classPacketHdr.html#p0">info_</a> + position;
00053   *(p++) =  b &gt;&gt; 8;
00054   *(p++) =  b &amp; 0xFF;
00055   <a class="code" href="classPacketHdr.html#p1">length_</a>+=2;
00056 }
00057 
00058 
00059 <span class="comment">//=================================================================</span>
00060 <span class="comment">//  Packet Class</span>
00061 
00062 Packet::Packet()
00063 {
00064   <a class="code" href="classPacket.html#p0">size_</a> = 0;
00065   <a class="code" href="classPacket.html#p1">length_</a> = <a class="code" href="classPacket.html#s0">DEFAULT_PAYLOAD_SIZE</a>;
00066   <a class="code" href="classPacket.html#p2">payload_</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[<a class="code" href="classPacket.html#s0">DEFAULT_PAYLOAD_SIZE</a>];
00067   <a class="code" href="classPacket.html#p3">header_</a> = <span class="keyword">new</span> <a class="code" href="classPacketHdr.html">PacketHdr</a>();
00068 }
00069 
<a name="l00075"></a><a class="code" href="classPacket.html#a1">00075</a> Packet::Packet(<span class="keywordtype">int</span> buffer_length)
00076 {
00077   <a class="code" href="classPacket.html#p0">size_</a> = 0;
00078   <a class="code" href="classPacket.html#p1">length_</a> = buffer_length;
00079   <a class="code" href="classPacket.html#p2">payload_</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[buffer_length];
00080   <a class="code" href="classPacket.html#p3">header_</a> = <span class="keyword">new</span> <a class="code" href="classPacketHdr.html">PacketHdr</a>();
00081 }
00082 
<a name="l00093"></a><a class="code" href="classPacket.html#a4">00093</a> <span class="keywordtype">void</span> <a class="code" href="classPacket.html#a4">Packet::setPayloadSize</a>(<span class="keywordtype">int</span> size)
00094 {
00095   <a class="code" href="classPacket.html#p0">size_</a> =  size;
00096   <span class="keywordflow">if</span> (size &gt; <a class="code" href="classPacket.html#p1">length_</a>) {
00097     <span class="keywordflow">if</span> (<a class="code" href="classPacket.html#p2">payload_</a> != NULL) <span class="keyword">delete</span> [] <a class="code" href="classPacket.html#p2">payload_</a>;
00098     <a class="code" href="classPacket.html#p1">length_</a> = (int)(1.5 * size);
00099     <a class="code" href="classPacket.html#p2">payload_</a> =  <span class="keyword">new</span> <span class="keywordtype">char</span>[<a class="code" href="classPacket.html#p1">length_</a>];
00100   }
00101 }
00102 
<a name="l00107"></a><a class="code" href="classPacket.html#a2">00107</a> <span class="keywordtype">int</span> <a class="code" href="classPacket.html#a2">Packet::fillPayload</a>(<span class="keywordtype">int</span> size, <span class="keywordtype">char</span> *inputstream)
00108 {
00109   <a class="code" href="classPacket.html#a4">setPayloadSize</a>(size);
00110   <span class="keywordflow">if</span> (memcpy((<span class="keywordtype">char</span> *)<a class="code" href="classPacket.html#p2">payload_</a>, (<span class="keywordtype">char</span> *)inputstream,  size) == NULL) {
00111     <span class="keywordflow">throw</span> <span class="stringliteral">"Fill payload Failed"</span>;
00112   }
00113   <span class="keywordflow">return</span> 0;
00114 }
00115 
<a name="l00120"></a><a class="code" href="classPacket.html#a10">00120</a> <span class="keywordtype">int</span> <a class="code" href="classPacket.html#a10">Packet::makePacket</a>( <span class="keywordtype">char</span> *streambuf )
00121 {
00122   streambuf[0]= ( <a class="code" href="classPacket.html#p3">header_</a>-&gt;<a class="code" href="classPacketHdr.html#a5">getSize</a>() ) &amp; 0xff;
00123   streambuf[1]=  0x00;
00124   memcpy(streambuf+1, <a class="code" href="classPacket.html#p3">header_</a>-&gt;<a class="code" href="classPacketHdr.html#a4">accessInfo</a>(), <a class="code" href="classPacket.html#p3">header_</a>-&gt;<a class="code" href="classPacketHdr.html#a5">getSize</a>());
00125   memcpy(streambuf+1+<a class="code" href="classPacket.html#p3">header_</a>-&gt;<a class="code" href="classPacketHdr.html#a5">getSize</a>(), <a class="code" href="classPacket.html#p2">payload_</a>, <a class="code" href="classPacket.html#p0">size_</a>);
00126   
00127   <span class="keywordflow">return</span> 1+<a class="code" href="classPacket.html#p0">size_</a>+ <a class="code" href="classPacket.html#p3">header_</a>-&gt;<a class="code" href="classPacketHdr.html#a5">getSize</a>();
00128 }
00129 
<a name="l00133"></a><a class="code" href="classPacket.html#a9">00133</a> <span class="keywordtype">void</span> <a class="code" href="classPacket.html#a9">Packet::extractHeader</a>( <span class="keywordtype">char</span> *streambuf )
00134 {
00135   <span class="keywordtype">char</span>* p= streambuf; 
00136   <span class="keywordtype">int</span> a  = *(p++);
00137   <a class="code" href="classPacket.html#p3">header_</a>-&gt;<a class="code" href="classPacketHdr.html#a9">setHeaderSize</a>(a);
00138   memcpy( <a class="code" href="classPacket.html#p3">header_</a>-&gt;<a class="code" href="classPacketHdr.html#a4">accessInfo</a>(), p ,a);   
00139 }
00140 
00141 
00142 <span class="comment">// =========================================================================</span>
00143 <span class="comment">// Address Class</span>
00144 
<a name="l00145"></a><a class="code" href="classAddress.html#a0">00145</a> <a class="code" href="classAddress.html#a0">Address::Address</a>():port_(-1)
00146 {   
00147   <a class="code" href="classAddress.html#p0">hostname_</a>[0] = <span class="charliteral">'\0'</span>;  
00148   <a class="code" href="classAddress.html#p3">macaddr_</a>[0] = <span class="charliteral">'\0'</span>;
00149 }
00150 
<a name="l00151"></a><a class="code" href="classAddress.html#a1">00151</a> <a class="code" href="classAddress.html#a0">Address::Address</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* hostname, <span class="keywordtype">short</span> port)
00152 { 
00153    <a class="code" href="classAddress.html#a3">setPort</a>(port); 
00154    <a class="code" href="classAddress.html#a5">setHostname</a>(hostname);
00155 }
00156 
<a name="l00163"></a><a class="code" href="classAddress.html#a9">00163</a> <span class="keywordtype">void</span> <a class="code" href="classAddress.html#a9">Address::setHWAddrFromColonFormat</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* colonmac)
00164 {  
00165   <span class="keywordtype">char</span> HexChar;
00166   <span class="comment">//First verify the address</span>
00167   <span class="keywordtype">int</span> Count  = 0;
00168   <span class="keywordtype">int</span> num_mac_char = 0;
00169   <span class="comment">/* Two ASCII characters per byte of binary data */</span>
00170   <span class="keywordtype">bool</span> error_end = <span class="keyword">false</span>;
00171   <span class="keywordflow">while</span> (!error_end)
00172     { <span class="comment">/* Scan string for first non-hex character.  Also stop scanning at end</span>
00173 <span class="comment">         of string (HexChar == 0), or when out of six binary storage space */</span>
00174       HexChar = (char)colonmac[Count++];
00175       <span class="keywordflow">if</span> (HexChar == <span class="charliteral">':'</span>) <span class="keywordflow">continue</span>;     
00176       <span class="keywordflow">if</span> (HexChar &gt; 0x39) HexChar = HexChar | 0x20;  <span class="comment">/* Convert upper case to lower */</span>
00177       <span class="keywordflow">if</span> ( (HexChar == 0x00) || num_mac_char  &gt;= (MAC_ADDR_LENGTH * 2) ||
00178            (!(((HexChar &gt;= 0x30) &amp;&amp; (HexChar &lt;= 0x39))||  <span class="comment">/* 0 - 9 */</span>
00179              ((HexChar &gt;= 0x61) &amp;&amp; (HexChar &lt;= 0x66))) ) ) <span class="comment">/* a - f */</span> 
00180         {
00181           error_end = <span class="keyword">true</span>;
00182         } <span class="keywordflow">else</span> 
00183             num_mac_char++;
00184     }
00185   <span class="keywordflow">if</span> (num_mac_char != MAC_ADDR_LENGTH * 2 )
00186     <span class="keywordflow">throw</span> <span class="stringliteral">"Given Wrong MAC address Format."</span>;
00187 
00188   <span class="comment">// Conversion</span>
00189   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> HexValue = 0x00;
00190   Count = 0;
00191   num_mac_char = 0;
00192   <span class="keywordtype">int</span> mac_byte_num = 0;
00193   <span class="keywordflow">while</span> (mac_byte_num &lt; MAC_ADDR_LENGTH )
00194     {
00195       HexChar = (char)colonmac[Count++];
00196       <span class="keywordflow">if</span> (HexChar == <span class="charliteral">':'</span>) <span class="keywordflow">continue</span>;
00197       num_mac_char++;  <span class="comment">// locate a HEX character</span>
00198       <span class="keywordflow">if</span> (HexChar &gt; 0x39)
00199         HexChar = HexChar | 0x20;  <span class="comment">/* Convert upper case to lower */</span>
00200       HexChar -= 0x30;
00201       <span class="keywordflow">if</span> (HexChar &gt; 0x09)  <span class="comment">/* HexChar is "a" - "f" */</span>
00202         HexChar -= 0x27;
00203       HexValue = (HexValue &lt;&lt; 4) | HexChar;
00204       <span class="keywordflow">if</span> (num_mac_char % 2  == 0 ) <span class="comment">/* If we've converted two ASCII chars... */</span>
00205         {
00206           <a class="code" href="classAddress.html#p3">macaddr_</a>[mac_byte_num] = HexValue;
00207           HexValue = 0x0;
00208           mac_byte_num++;
00209         }
00210     }  
00211   <span class="keywordflow">return</span>;   
00212 }
00213 
00214 
<a name="l00218"></a><a class="code" href="classAddress.html#a10">00218</a> <span class="keywordtype">char</span> *<a class="code" href="classAddress.html#a10">Address::convertHWAddrToColonFormat</a>()
00219 {
00220   <span class="keywordtype">char</span> *colonformat =  <span class="keyword">new</span> <span class="keywordtype">char</span>[17];
00221   <span class="comment">//printf("HW Address: %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\n",u[0], u[1], u[2], u[3], u[4], u[5]);</span>
00222   sprintf(colonformat,<span class="stringliteral">"%02X:%02X:%02X:%02X:%02X:%02X"</span>,
00223           <a class="code" href="classAddress.html#p3">macaddr_</a>[0],<a class="code" href="classAddress.html#p3">macaddr_</a>[1],<a class="code" href="classAddress.html#p3">macaddr_</a>[2],<a class="code" href="classAddress.html#p3">macaddr_</a>[3],<a class="code" href="classAddress.html#p3">macaddr_</a>[4],<a class="code" href="classAddress.html#p3">macaddr_</a>[5]);
00224   <span class="comment">// cout &lt;&lt; colonformat &lt;&lt; endl;</span>
00225   <span class="keywordflow">return</span> colonformat;
00226 
00227 }
00228 
<a name="l00232"></a><a class="code" href="classAddress.html#a8">00232</a> <span class="keywordtype">void</span> <a class="code" href="classAddress.html#a8">Address::setHWAddr</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* hwaddr)
00233 {
00234   memcpy(<a class="code" href="classAddress.html#p3">macaddr_</a>, hwaddr , MAC_ADDR_LENGTH*<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));
00235 }
00236 
<a name="l00241"></a><a class="code" href="classAddress.html#a13">00241</a> <span class="keywordtype">bool</span> <a class="code" href="classAddress.html#a13">Address::isSameMACAddr</a>( <a class="code" href="classAddress.html">Address</a> *addr)
00242 {
00243   <span class="keywordflow">if</span> ( memcmp(<a class="code" href="classAddress.html#p3">macaddr_</a>, addr-&gt;<a class="code" href="classAddress.html#a7">getHWAddr</a>(), MAC_ADDR_LENGTH*<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> char))  == 0 )
00244            <span class="keywordflow">return</span> <span class="keyword">true</span>;
00245   <span class="keywordflow">return</span> <span class="keyword">false</span>;
00246 
00247 }
00248 
<a name="l00249"></a><a class="code" href="classAddress.html#a11">00249</a> <a class="code" href="classAddress.html">Address</a>* <a class="code" href="classAddress.html#a11">Address::clone</a>()
00250 {
00251   <a class="code" href="classAddress.html">Address</a> * ad =  <span class="keyword">new</span> <a class="code" href="classAddress.html#a0">Address</a>(<a class="code" href="classAddress.html#p0">hostname_</a>, <a class="code" href="classAddress.html#p1">port_</a>);
00252   ad-&gt;<a class="code" href="classAddress.html#a8">setHWAddr</a>(<a class="code" href="classAddress.html#p3">macaddr_</a>);
00253   <span class="keywordflow">return</span> ad;
00254 }
00255 
00256 <span class="comment">//===============================================================</span>
00257 <span class="comment">// Port Class</span>
00258 
<a name="l00263"></a><a class="code" href="classPort.html#a0">00263</a> <a class="code" href="classPort.html#a0">Port::Port</a>():sockfd_(0)
00264 {
00265 }
00266 
<a name="l00267"></a><a class="code" href="classPort.html#a3">00267</a> <span class="keywordtype">void</span> <a class="code" href="classPort.html#a3">Port::setAddress</a>(<a class="code" href="classAddress.html">Address</a>* addr)
00268 {
00269   <a class="code" href="classPort.html#b2">setHostname</a>(addr-&gt;<a class="code" href="classAddress.html#a6">getHostname</a>());
00270   <a class="code" href="classPort.html#b3">setPort</a>(addr-&gt;<a class="code" href="classAddress.html#a4">getPort</a>());
00271 }
00272 
<a name="l00273"></a><a class="code" href="classPort.html#a4">00273</a> <span class="keywordtype">void</span> <a class="code" href="classPort.html#a4">Port::setRemoteAddress</a>(<a class="code" href="classAddress.html">Address</a>* daddr)
00274 {
00275   <a class="code" href="classPort.html#b4">setRemoteHostname</a>(daddr-&gt;<a class="code" href="classAddress.html#a6">getHostname</a>());
00276   <a class="code" href="classPort.html#b5">setRemotePort</a>(daddr-&gt;<a class="code" href="classAddress.html#a4">getPort</a>());
00277 }
00278 
<a name="l00287"></a><a class="code" href="classPort.html#b0">00287</a> <span class="keyword">struct </span>sockaddr * <a class="code" href="classPort.html#b0">Port::setSockAddress</a>(<a class="code" href="classAddress.html">Address</a> *addr, <span class="keyword">struct</span> sockaddr_in *address)
00288 {
00289   <span class="keywordtype">char</span> *hostname;
00290   <span class="keywordtype">int</span> port;
00291   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp;
00292   <span class="keyword">struct </span>hostent *hp;
00293 
00294   hostname = addr-&gt;<a class="code" href="classAddress.html#a6">getHostname</a>();
00295   port = addr-&gt;<a class="code" href="classAddress.html#a4">getPort</a>();
00296 
00297   address-&gt;sin_family = AF_INET;
00298   address-&gt;sin_port   = htons((<span class="keywordtype">short</span>)port);
00299       
00300   <span class="keywordflow">if</span> (strcmp(hostname, <span class="stringliteral">""</span>) == 0) {
00301     address-&gt;sin_addr.s_addr = htonl(INADDR_ANY);  
00302   } 
00303   <span class="keywordflow">else</span> {
00304     <span class="comment">//tmp = inet_addr(hostname);  // If an IP address is given</span>
00305     tmp = inet_aton(hostname, &amp;(address-&gt;sin_addr));
00306     <span class="comment">//if(tmp != (unsigned long) INADDR_NONE){    </span>
00307     <span class="comment">//  address-&gt;sin_addr.s_addr = tmp;  </span>
00308     <span class="comment">//}</span>
00309     <span class="keywordflow">if</span> (tmp == 0) 
00310     {  <span class="comment">// if a hostname is passed, call DNS</span>
00311       <span class="keywordflow">if</span> ((hp = gethostbyname(hostname)) == NULL) {
00312         herror(<span class="stringliteral">"gethostbyname"</span>);
00313         <span class="keywordflow">throw</span> <span class="stringliteral">"Error in Resolving hostname!"</span> ;                           
00314       }
00315       memcpy((<span class="keywordtype">char</span> *)&amp;address-&gt;sin_addr, (<span class="keywordtype">char</span> *)hp-&gt;h_addr, hp-&gt;h_length);
00316     }
00317   }
00318   <span class="keywordflow">return</span> (sockaddr*)address;
00319 }
00320 
<a name="l00325"></a><a class="code" href="classPort.html#b1">00325</a> <span class="keywordtype">void</span> <a class="code" href="classPort.html#b1">Port::decodeSockAddress</a>(<a class="code" href="classAddress.html">Address</a> *addr, <span class="keyword">struct</span> sockaddr_in *address)
00326 {
00327   addr-&gt;setHostname(inet_ntoa(address-&gt;sin_addr));
00328   addr-&gt;setPort(ntohs(address-&gt;sin_port));  
00329 }
00330 
00331 
00332 
00333 <span class="comment">//==========================================================</span>
00334 <span class="comment">// Sending Port Class</span>
00335 
00336 
00337 SendingPort::SendingPort(): <a class="code" href="classPort.html">Port</a>(),bcastflag_(0),timer_(this)
00338 {
00339   <a class="code" href="classPort.html#b2">setHostname</a>(<span class="stringliteral">"localhost"</span>); 
00340   <a class="code" href="classPort.html#b3">setPort</a>(DEFAULT_SEND_PORT);  
00341   <span class="comment">// setRemoteHostname("internal2");  </span>
00342 }
00343 
00344 
<a name="l00345"></a><a class="code" href="classSendingPort.html#a1">00345</a> SendingPort::SendingPort(<span class="keywordtype">char</span> *hostname, <span class="keywordtype">short</span> port):<a class="code" href="classPort.html">Port</a>(),bcastflag_(0),timer_(this)
00346 {
00347   <a class="code" href="classPort.html#b2">setHostname</a>(hostname);
00348   <a class="code" href="classPort.html#b3">setPort</a>(port);
00349   <span class="comment">//setRemotePort(DEFAULT_RECV_PORT); </span>
00350 }
00351 
<a name="l00365"></a><a class="code" href="classSendingPort.html#a3">00365</a> <span class="keywordtype">void</span> <a class="code" href="classSendingPort.html#a3">SendingPort::init</a>()
00366 {
00367   <span class="comment">//"0" shows the sockfd is uninitialized, -1 means error</span>
00368   <span class="keywordflow">if</span> (<a class="code" href="classPort.html#p4">sockfd_</a> != 0) {
00369     cout &lt;&lt; <span class="stringliteral">"socket has not been properly initialized!"</span> &lt;&lt; endl;
00370     <span class="keywordflow">return</span>;
00371   }
00372   <span class="keywordflow">if</span> ( <a class="code" href="classPort.html#p0">myaddr_</a>.<a class="code" href="classAddress.html#a2">isSet</a>() == <span class="keyword">false</span>) {
00373     <a class="code" href="classPort.html#b2">setHostname</a>(<span class="stringliteral">"localhost"</span>);
00374     <a class="code" href="classPort.html#b3">setPort</a>(DEFAULT_SEND_PORT);
00375   }
00376   <span class="comment">//check if itsaddr_ is set</span>
00377   <span class="keywordflow">if</span> ( <a class="code" href="classPort.html#p1">itsaddr_</a>.<a class="code" href="classAddress.html#a2">isSet</a>() == <span class="keyword">false</span>)
00378     <span class="keywordflow">throw</span> <span class="stringliteral">"Destination address of a sending port is not set!"</span>;
00379 
00380   <span class="keywordflow">if</span> ((<a class="code" href="classPort.html#p4">sockfd_</a> = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
00381     perror(<span class="stringliteral">"socket"</span>);
00382     <span class="keywordflow">throw</span> <span class="stringliteral">"Error while opening a UDP socket"</span>;
00383   }
00384   <a class="code" href="classAddress.html">Address</a> *emptyAddr = <span class="keyword">new</span> <a class="code" href="classAddress.html">Address</a>(<span class="stringliteral">""</span>, <a class="code" href="classPort.html#p0">myaddr_</a>.<a class="code" href="classAddress.html#a4">getPort</a>());
00385   <span class="keyword">struct </span>sockaddr* addr = <a class="code" href="classPort.html#b0">setSockAddress</a>(emptyAddr, &amp;<a class="code" href="classPort.html#p2">mySockAddress_</a>);
00386   <span class="keywordflow">if</span> (  bind(<a class="code" href="classPort.html#p4">sockfd_</a>, addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))  &lt; 0 ){
00387     perror(<span class="stringliteral">"bind"</span>);
00388     <span class="keywordflow">throw</span> <span class="stringliteral">"Scoket Bind Error"</span>;
00389   }
00390    
00391   <span class="keywordflow">if</span> (<a class="code" href="classSendingPort.html#p0">bcastflag_</a> == 1) 
00392     <span class="keywordflow">if</span> (setsockopt(<a class="code" href="classPort.html#p4">sockfd_</a>,SOL_SOCKET,SO_BROADCAST,&amp;<a class="code" href="classSendingPort.html#p0">bcastflag_</a>,<span class="keyword">sizeof</span>(<a class="code" href="classSendingPort.html#p0">bcastflag_</a>)) == -1   )
00393          {
00394            perror(<span class="stringliteral">"setsockopt"</span>);
00395            <span class="keywordflow">throw</span> <span class="stringliteral">"Set broadcast option failed."</span>;
00396          }; 
00397 
00398   <span class="comment">//create sending buffer</span>
00399   <a class="code" href="classSendingPort.html#p1">sendingbuf_</a> = <span class="keyword">new</span> <span class="keywordtype">char</span>[MTU_SIZE+1];
00400   <span class="keywordflow">return</span>; 
00401 
00402 }
00403 
<a name="l00409"></a><a class="code" href="classSendingPort.html#a4">00409</a> <span class="keywordtype">void</span> <a class="code" href="classSendingPort.html#a4">SendingPort::sendPacket</a>(<a class="code" href="classPacket.html">Packet</a>* pkt)
00410 {  
00411    <span class="keywordtype">int</span> pktlen = pkt-&gt;<a class="code" href="classPacket.html#a10">makePacket</a>(<a class="code" href="classSendingPort.html#p1">sendingbuf_</a>); 
00412    <a class="code" href="classAddress.html">Address</a> *dst = <a class="code" href="classPort.html#a5">getRemoteAddr</a>();
00413    <span class="keywordtype">int</span>  length = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr_in); 
00414    <span class="keyword">struct </span>sockaddr *dest = <a class="code" href="classPort.html#b0">setSockAddress</a>(dst, &amp;<a class="code" href="classPort.html#p3">dstSockAddress_</a>);
00415    <span class="keywordtype">int</span> len = sendto(<a class="code" href="classPort.html#p4">sockfd_</a>, <a class="code" href="classSendingPort.html#p1">sendingbuf_</a>, pktlen, 0, dest, length); 
00416    <span class="keywordflow">if</span> (len == -1) 
00417    { 
00418          perror(<span class="stringliteral">"send"</span>);
00419          <span class="keywordflow">throw</span> <span class="stringliteral">"Sending Error."</span>;
00420    }
00421 }
00422 
00423 <span class="comment">//====================================================================</span>
00424 <span class="comment">// Functions of ReceivingPort class</span>
<a name="l00429"></a><a class="code" href="classReceivingPort.html#a0">00429</a> <span class="comment"></span><a class="code" href="classReceivingPort.html#a0">ReceivingPort::ReceivingPort</a>(): <a class="code" href="classPort.html">Port</a>()
00430 {
00431   <a class="code" href="classReceivingPort.html#p0">pkt_</a>= <span class="keyword">new</span> <a class="code" href="classPacket.html">Packet</a>(MAXBUFLENGTH);
00432 }
00433 
<a name="l00448"></a><a class="code" href="classReceivingPort.html#a2">00448</a> <span class="keywordtype">void</span> <a class="code" href="classReceivingPort.html#a2">ReceivingPort::init</a>()
00449 { 
00450   <span class="keywordflow">if</span> (<a class="code" href="classPort.html#p4">sockfd_</a> != 0) {
00451     <span class="keywordflow">return</span>;
00452   }
00453   <span class="keywordflow">if</span> ( <a class="code" href="classPort.html#p0">myaddr_</a>.<a class="code" href="classAddress.html#a2">isSet</a>() == <span class="keyword">false</span>) {
00454     <a class="code" href="classPort.html#b2">setHostname</a>(<span class="stringliteral">"localhost"</span>);
00455     <a class="code" href="classPort.html#b3">setPort</a>(DEFAULT_RECV_PORT);
00456   }
00457   
00458   <span class="keywordflow">if</span> ((<a class="code" href="classPort.html#p4">sockfd_</a> = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) {
00459     <span class="keywordflow">throw</span> <span class="stringliteral">"Error while opening UDP socket of a receiver"</span>;
00460   }
00461   <a class="code" href="classAddress.html">Address</a> *emptyAddr = <span class="keyword">new</span> <a class="code" href="classAddress.html">Address</a>(<span class="stringliteral">""</span>, <a class="code" href="classPort.html#p0">myaddr_</a>.<a class="code" href="classAddress.html#a4">getPort</a>());
00462   <span class="keyword">struct </span>sockaddr* addr = <a class="code" href="classPort.html#b0">setSockAddress</a>(emptyAddr, &amp;<a class="code" href="classPort.html#p2">mySockAddress_</a>);
00463   <span class="keywordflow">if</span> (  bind(<a class="code" href="classPort.html#p4">sockfd_</a>, addr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in))  &lt; 0 ){
00464     <span class="keywordflow">throw</span> <span class="stringliteral">"Scoket Bind Error occured in an UDP receiver"</span>;
00465   }
00466   <span class="comment">//cout &lt;&lt; "binding to port: " &lt;&lt; myaddr_.getPort() &lt;&lt; "......" &lt;&lt; endl;</span>
00467   <span class="comment">// needs a dummy buffer for storing packets</span>
00468   <a class="code" href="classReceivingPort.html#p1">tmpBuffer_</a> =  <span class="keyword">new</span> <span class="keywordtype">char</span>[MAXBUFLENGTH];
00469 }
00470 
<a name="l00484"></a><a class="code" href="classReceivingPort.html#a3">00484</a> <a class="code" href="classPacket.html">Packet</a>* <a class="code" href="classReceivingPort.html#a3">ReceivingPort::receivePacket</a>()
00485 {
00486   <span class="keyword">struct </span>sockaddr_in tmpSockAddr;
00487   <span class="keywordtype">int</span> length = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>sockaddr);
00488   <span class="keywordtype">int</span> len = (int)recvfrom(<a class="code" href="classPort.html#p4">sockfd_</a>, <a class="code" href="classReceivingPort.html#p1">tmpBuffer_</a>, MAXBUFLENGTH, 0, (<span class="keyword">struct</span> sockaddr*)&amp;tmpSockAddr,(socklen_t *)&amp;length); 
00489   <span class="keywordflow">if</span> (len == -1) 
00490   {
00491            perror(<span class="stringliteral">"recvfrom"</span>);
00492            <span class="keywordflow">return</span> <span class="keyword">false</span>;
00493   }         
00494   <a class="code" href="classPort.html#b1">decodeSockAddress</a>( &amp;<a class="code" href="classPort.html#p1">itsaddr_</a>, &amp;tmpSockAddr);
00495   <a class="code" href="classReceivingPort.html#p0">pkt_</a>-&gt;<a class="code" href="classPacket.html#a9">extractHeader</a>(<a class="code" href="classReceivingPort.html#p1">tmpBuffer_</a>);
00496   <span class="comment">//tmpBuffer_ pointer shall not be moved/shifted,it will reused by the receiving port.</span>
00497   <a class="code" href="classReceivingPort.html#p0">pkt_</a>-&gt;<a class="code" href="classPacket.html#a2">fillPayload</a>(len-1-<a class="code" href="classReceivingPort.html#p0">pkt_</a>-&gt;<a class="code" href="classPacket.html#a7">getHeaderSize</a>(), <a class="code" href="classReceivingPort.html#p1">tmpBuffer_</a>+<a class="code" href="classReceivingPort.html#p0">pkt_</a>-&gt;<a class="code" href="classPacket.html#a7">getHeaderSize</a>()+1 );
00498   <span class="keywordflow">return</span> <a class="code" href="classReceivingPort.html#p0">pkt_</a>;
00499 }
00500  
00501 <span class="comment">//===================================================================</span>
00502 <span class="comment">//    LossyReceivingPort class</span>
<a name="l00507"></a><a class="code" href="classLossyReceivingPort.html#a0">00507</a> <span class="comment"></span><a class="code" href="classLossyReceivingPort.html#a0">LossyReceivingPort::LossyReceivingPort</a>(<span class="keywordtype">float</span> lossyratio): <a class="code" href="classReceivingPort.html">ReceivingPort</a>(), loss_ratio_(lossyratio),secdelay_(1)
00508 {
00509 }
00510 
<a name="l00514"></a><a class="code" href="classLossyReceivingPort.html#a2">00514</a> <a class="code" href="classPacket.html">Packet</a>* <a class="code" href="classLossyReceivingPort.html#a2">LossyReceivingPort::receivePacket</a>()
00515 {   
00516   <a class="code" href="classPacket.html">Packet</a> *p = <a class="code" href="classReceivingPort.html#a3">ReceivingPort::receivePacket</a>();
00517   <span class="comment">//simulate some delay</span>
00518   sleep(<a class="code" href="classLossyReceivingPort.html#p1">secdelay_</a>); <span class="comment">//delay</span>
00519   <span class="keywordtype">float</span>  x;
00520   <span class="comment">// Set evil seed (initial seed)</span>
00521   srand( (<span class="keywordtype">unsigned</span>)time( NULL ) );
00522   x = (double) rand()/RAND_MAX;
00523   <span class="comment">//cout &lt;&lt; x &lt;&lt; endl;</span>
00524   <span class="keywordflow">if</span> ( x &lt;= <a class="code" href="classLossyReceivingPort.html#p0">loss_ratio_</a>) 
00525     <span class="keywordflow">return</span> NULL;
00526   <span class="keywordflow">else</span>
00527     <span class="keywordflow">return</span> p;
00528 }
00529 
00530 
00531 <span class="comment">//====================================================</span>
00533 <span class="comment"></span><span class="comment">//===================================================</span>
00534 
<a name="l00535"></a><a class="code" href="classTxTimer.html#a0">00535</a> <a class="code" href="classTxTimer.html#a0">TxTimer::TxTimer</a>(<a class="code" href="classSendingPort.html">SendingPort</a> *txport)
00536 {
00537   <a class="code" href="classTxTimer.html#p0">port_</a> = txport;  
00538   <a class="code" href="classTxTimer.html#p1">tdelay_</a>.tv_nsec = 0;
00539   <a class="code" href="classTxTimer.html#p1">tdelay_</a>.tv_sec =  0; 
00540 }
00541 
<a name="l00542"></a><a class="code" href="classTxTimer.html#e0">00542</a> <span class="keywordtype">void</span> *<a class="code" href="classTxTimer.html#e0">TxTimer::timerProc</a>(<span class="keywordtype">void</span> *arg) {
00543   <a class="code" href="classTxTimer.html">TxTimer</a> *th = (<a class="code" href="classTxTimer.html">TxTimer</a> *)arg;
00544   nanosleep(&amp;(th-&gt;<a class="code" href="classTxTimer.html#p1">tdelay_</a>), NULL);
00545   th-&gt;<a class="code" href="classTxTimer.html#p0">port_</a>-&gt;<a class="code" href="classSendingPort.html#a7">timerHandler</a>(); 
00546   <span class="keywordflow">return</span> NULL;
00547 }
00548 
<a name="l00549"></a><a class="code" href="classTxTimer.html#a1">00549</a> <span class="keywordtype">void</span> <a class="code" href="classTxTimer.html#a1">TxTimer::startTimer</a>(<span class="keywordtype">float</span> delay)
00550 {
00551   <a class="code" href="classTxTimer.html#p1">tdelay_</a>.tv_nsec = (<span class="keywordtype">long</span> int)((delay - (int)delay)*1e9);
00552   <a class="code" href="classTxTimer.html#p1">tdelay_</a>.tv_sec =  (int)delay; 
00553   <span class="keywordtype">int</span> error = pthread_create(&amp;<a class="code" href="classTxTimer.html#p2">tid_</a>, NULL, &amp;<a class="code" href="classTxTimer.html#e0">timerProc</a>, <span class="keyword">this</span> );
00554   <span class="keywordflow">if</span> (error) 
00555     <span class="keywordflow">throw</span> <span class="stringliteral">"Timer thread creation failed..."</span>;
00556   
00557 }
<a name="l00558"></a><a class="code" href="classTxTimer.html#a2">00558</a> <span class="keywordtype">void</span> <a class="code" href="classTxTimer.html#a2">TxTimer::stopTimer</a>()
00559 {
00560   pthread_cancel(<a class="code" href="classTxTimer.html#p2">tid_</a>);
00561 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Feb 17 17:55:49 2006 for Common_Classes_Projects_ECE544 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
